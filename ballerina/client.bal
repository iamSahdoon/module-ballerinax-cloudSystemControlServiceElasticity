// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

import ballerina/http;

# Creates , amends and retrieves the service profile elasticity features including upscaling and downscaling of processing agents, enabling dynamic provisioning and cleaning up inactive pods
public isolated client class Client {
    final http:Client clientEp;
    final readonly & ApiKeysConfig? apiKeyConfig;
    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string serviceUrl = "https://api.temenos.com/api/v1.1.0/system") returns error? {
        http:ClientConfiguration httpClientConfig = {httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        if config.auth is ApiKeysConfig {
            self.apiKeyConfig = (<ApiKeysConfig>config.auth).cloneReadOnly();
        } else {
            httpClientConfig.auth = <http:CredentialsConfig>config.auth;
            self.apiKeyConfig = ();
        }
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Create cleanup instruction to initiate cleanup of downscaled servers
    #
    # + serverName - Contains the name of the server on which the service will run.  In cloud mode, it refers to pod or container
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ServiceElasticCleanupResponse 
    resource isolated function post services/elasticity/servers/[string serverName]/serviceCleanups(http:Request request, CreateServiceElasticCleanupHeaders headers = {}, *CreateServiceElasticCleanupQueries queries) returns ServiceElasticCleanupResponse|error {
        string resourcePath = string `/services/elasticity/servers/${getEncodedUri(serverName)}/serviceCleanups`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update dynamic provisioning for system deployed in cloud
    #
    # + settingId - Contains the particular parameter record setting identifier
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ServiceElasticParameterResponse 
    resource isolated function put services/settings/[string settingId]/elasticity(http:Request request, AmendServiceElasticParameterHeaders headers = {}, *AmendServiceElasticParameterQueries queries) returns ServiceElasticParameterResponse|error {
        string resourcePath = string `/services/settings/${getEncodedUri(settingId)}/elasticity`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Update number of agents for elastic scaling
    #
    # + workProfileId - Contains the reference to the record in service workload profiles for services
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ServiceElasticProfileResponse 
    resource isolated function put services/workProfiles/[string workProfileId]/elasticity(http:Request request, AmendServiceElasticProfileHeaders headers = {}, *AmendServiceElasticProfileQueries queries) returns ServiceElasticProfileResponse|error {
        string resourcePath = string `/services/workProfiles/${getEncodedUri(workProfileId)}/elasticity`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Create number of agents for elastic scaling
    #
    # + workProfileId - Contains the reference to the record in service workload profiles for services
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - ServiceElasticProfileResponse 
    resource isolated function post services/workProfiles/[string workProfileId]/elasticity(http:Request request, CreateServiceElasticProfileHeaders headers = {}, *CreateServiceElasticProfileQueries queries) returns ServiceElasticProfileResponse|error {
        string resourcePath = string `/services/workProfiles/${getEncodedUri(workProfileId)}/elasticity`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->post(resourcePath, request, httpHeaders);
    }

    # Update the system deployment mode
    #
    # + settingId - Contains the particular parameter record setting identifier
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + request - body Payload 
    # + return - SystemParameterElasticResponse 
    resource isolated function put settings/[string settingId]/deploymentModes(http:Request request, AmendSystemParameterElasticHeaders headers = {}, *AmendSystemParameterElasticQueries queries) returns SystemParameterElasticResponse|error {
        string resourcePath = string `/settings/${getEncodedUri(settingId)}/deploymentModes`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        // TODO: Update the request as needed;
        return self.clientEp->put(resourcePath, request, httpHeaders);
    }

    # Retrieves the total number of agents required for cloud deployment
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - AgentElasticCheckResponse 
    resource isolated function get metrics/elasticity/agents/itemCount(GetAgentElasticCheckHeaders headers = {}, *GetAgentElasticCheckQueries queries) returns AgentElasticCheckResponse|error {
        string resourcePath = string `/metrics/elasticity/agents/itemCount`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves the agent details for active services in cloud deployment
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - AgentElasticCheckDetailsResponse 
    resource isolated function get services/elasticity/agents(GetAgentElasticCheckDetailsHeaders headers = {}, *GetAgentElasticCheckDetailsQueries queries) returns AgentElasticCheckDetailsResponse|error {
        string resourcePath = string `/services/elasticity/agents`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }

    # Retrieves last contact and server details for cloud mode
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - ElasticityServersDetailsResponse 
    resource isolated function get services/elasticity/servers(GetElasticityServersDetailsHeaders headers = {}, *GetElasticityServersDetailsQueries queries) returns ElasticityServersDetailsResponse|error {
        string resourcePath = string `/services/elasticity/servers`;
        map<anydata> headerValues = {...headers};
        if self.apiKeyConfig is ApiKeysConfig {
            headerValues["apikey"] = self.apiKeyConfig?.apikey;
        }
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        map<string|string[]> httpHeaders = http:getHeaderMap(headerValues);
        return self.clientEp->get(resourcePath, httpHeaders);
    }
}
